# User Management System

This project implements a user management system with features for secure login and registration. It includes password hashing, JWT-based authentication, and role-based access control to ensure data security and controlled access to resources and routes.

## Table of Contents

- [User Roles](#user-roles)
- [Login and Registration Implementation](#login-and-registration-implementation)
  - [Registration Process](#registration-process)
  - [Login Process](#login-process)
- [Role-based access](#role-based-access)

## User Roles

The system currently supports two primary user roles:

1. **Employee**: Standard users with access to basic features in the application.
2. **Manager**: Users with additional privileges, allowing access to management features (e.g. adding, deleting, and editing users; deleting and editing waste reports).

Each user has a unique `EmployeeId` for identification, used during login along with their password. Roles are assigned dynamically based on the user's record in the database.

## Login and Registration Implementation

### Registration Process

Registration of new users is done by a user with a Role - Manager. Upon registration, basic information is provided including `Name`, `EmployeeId`, `Password`, and `Role`. The password is securely hashed using bcrypt before being stored in the database. 

#### Code Example
- **Controller:**

```csharp
[HttpPost("register")]
public async Task<IActionResult> PostPerson([FromBody] IPerson person)
{        
    var result = await _peopleService.PostPerson(person);
        
    if (result == "Success")
    {
        return Ok("User registered successfully.");
    }

    return BadRequest(result);
}
```

- **Service:**

```csharp
public async Task<string> PostPerson(IPerson person) {
  try {
    // Ensure the password is hashed
    person.Password = BCrypt.Net.BCrypt.HashPassword(person.Password);

    // Read the existing people data from the database
    var peopleArray = await _databaseService.ReadDBAsync();

    // Check if a person with the same EmployeeId exists and is inactive
    var existingPerson = peopleArray.FirstOrDefault(
        p => p["EmployeeId"]?.Value<string>() == person.EmployeeId.ToString());

    if (existingPerson != null) {
      if (existingPerson["IsActive"]?.Value<bool>() == false) {
        // Reactivate the existing person by setting IsActive to true
        existingPerson["IsActive"] = true;
        existingPerson["Password"] =
            person.Password;  // Update password if needed
        existingPerson["ModifiedOn"] = DateTime.Now;
      } else {
        // If the person is active, throw an exception
        throw new Exception("Employee ID already exists and is active.");
      }
    } else {
      // Add new person if no record with the EmployeeId exists
      var newPerson = JObject.FromObject(person);
      newPerson["CreatedOn"] = DateTime.Now;
      peopleArray.Add(newPerson);
    }

    // Write the updated data back to the database
    await _databaseService.WriteDBAsync(peopleArray);
    return "Success";
  } catch (Exception ex) {
    Console.WriteLine($"Error in PostPerson: {ex.Message}");
    return ex.Message;
  }
}
```

---

### Login Process

For login, users authenticate by submitting their EmployeeId and Password. If successful, a JWT token is generated and returned. This token can then be used to access protected resources/routes.
#### Code Example
- **Controller:**

```csharp
[HttpPost("login")]
public async Task<IActionResult> Login([FromBody] IPerson person)
{
    var people = await _peopleService.GetPeople(employeeId: person.EmployeeId, active: "true");
    var foundPerson = people.FirstOrDefault();

    if (foundPerson == null)
    {
        return Unauthorized("Invalid employee ID or inactive account.");
    }

    bool isPasswordValid = BCrypt.Net.BCrypt.Verify(person.Password, foundPerson.Password);
    if (!isPasswordValid)
    {
        return Unauthorized("Invalid password.");
    }

    var securityKey = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(_config["Jwt:Key"]));
    var credentials = new SigningCredentials(securityKey, SecurityAlgorithms.HmacSha256);

    var token = new JwtSecurityToken(
        _config["Jwt:Issuer"],
        _config["Jwt:Issuer"],
        null,
        expires: DateTime.Now.AddMinutes(120),
        signingCredentials: credentials);

    var jwtToken = new JwtSecurityTokenHandler().WriteToken(token);

    // Add Role to the response
    var response = new { Token = jwtToken, EmployeeId = foundPerson.EmployeeId, Role = foundPerson.Role };

    return Ok(response);
}
```
- **Service:**

```csharp
public async Task<List<PersonBase>> GetPeople(string? role = null,
                                              string? active = null,
                                              string? employeeId = null) {
  try {
    var peopleArray = await _databaseService.ReadDBAsync();

    // Apply all filters
    peopleArray = new JArray(peopleArray.Where(
        p => (role == null || p["Role"]?.Value<string>() == role) &&
             (active == null ||
              p["IsActive"]?.Value<bool>() == bool.Parse(active)) &&
             (employeeId == null ||
              p["EmployeeId"]?.Value<string>() == employeeId)));

    var peopleList = JsonConvert.DeserializeObject<List<PersonBase>>(
        peopleArray.ToString(), settings);
    return peopleList!;
  } catch (Exception ex) {
    Console.WriteLine($"Error in GetPeople: {ex.Message}");
    return new List<PersonBase>();
  }
}
```

### Blazor Login Page

In the Blazor front end, the login page handles user authentication, stores the JWT token in local storage, and redirects the user to the dashboard upon successful login.

#### Code Example

```razor
@page "/login"
@layout Layout.EmptyLayout
@inject IHttpClientFactory ClientFactory
@inject ILocalStorageService LocalStorage
@inject NavigationManager NavigationManager

<div class="d-flex justify-content-center align-items-center vh-100">
    <div class="p-4" style="width: 100%; max-width: 400px;">

        <div style="display: flex; justify-content: center;">
            <img src="images/salling-group-logo.png" alt="Salling Group Logo">
        </div>
        
        <h2 class="text-center mb-4">Login</h2>

        <EditForm Model="@loginModel" OnValidSubmit="@HandleLogin" FormName="loginForm">
            <DataAnnotationsValidator />
            <ValidationSummary />

            <div class="form-group">
                <label for="employeeId">Employee ID</label>
                <InputText id="employeeId" class="form-control" @bind-Value="loginModel.EmployeeId" placeholder="(e.g. 123456)" style="font-size: 18px;" />
            </div>

            <div class="form-group mt-3">
                <label for="password">Password</label>
                <InputText id="password" class="form-control" type="password" @bind-Value="loginModel.Password" placeholder="(e.g. 1234)" style="font-size: 18px;" />
            </div>

            <button type="submit" class="btn btn-primary w-100 mt-4" style="font-size: 20px;">Login</button>
        </EditForm>
    </div>
</div>

@code {
    [SupplyParameterFromForm]
    private PersonBase loginModel { get; set; } = new PersonBase();

    private async Task HandleLogin()
    {
        try
        {
            var client = ClientFactory.CreateClient("BackendAPI");
            var response = await client.PostAsJsonAsync("api/People/login", loginModel);

            if (response.IsSuccessStatusCode)
            {
                var responseData = await response.Content.ReadFromJsonAsync<Dictionary<string, string>>();
                if (responseData != null &&
                    responseData.TryGetValue("token", out var token) &&
                    responseData.TryGetValue("employeeId", out var employeeId) &&
                    responseData.TryGetValue("role", out var role)) // Retrieve role from response
                {                    
                    await LocalStorage.SetItemAsync("authToken", token);
                    await LocalStorage.SetItemAsync("employeeId", employeeId);
                    await LocalStorage.SetItemAsync("userRole", role); // Store role in local storage

                    Console.WriteLine("Login successful. Token and Role stored.");
                    
                    // Redirect to the employee's dashboard
                    NavigationManager.NavigateTo($"/dashboard");
                }
                else
                {
                    Console.WriteLine("Login succeeded but token, employeeId, or role was not received.");
                }
            }
            else
            {
                Console.WriteLine("Login failed");
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error: {ex.Message}");
        }
    }
}
```

## Role-based access
This code snippet demonstrates role-based access control in Blazor by dynamically rendering UI elements based on the user's role:

```razor
@inject HttpClient HttpClient
@inject AuthService AuthService
@inject NavigationManager NavigationManager
@inject ILocalStorageService LocalStorage

<div class="dropdown">
    <button class="user-profile-btn btn btn-link position-relative" type="button" data-bs-toggle="dropdown" aria-expanded="false" style="margin: 0;">
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="currentColor" class="bi bi-person-circle" viewBox="0 0 16 16">
            <path d="M11 6a3 3 0 1 1-6 0 3 3 0 0 1 6 0"/>
            <path fill-rule="evenodd" d="M0 8a8 8 0 1 1 16 0A8 8 0 0 1 0 8m8-7a7 7 0 0 0-5.468 11.37C3.242 11.226 4.805 10 8 10s4.757 1.225 5.468 2.37A7 7 0 0 0 8 1"/>
        </svg>
    </button>

    <ul class="dropdown-menu" aria-labelledby="userProfileDropdown" style="padding: 0;">
        @if (UserRole == "Manager")
        {
            <li>
                <button class="dropdown-item d-flex align-items-center rounded-top action-button" @onclick="NavigateToUsersPage">
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-people-fill me-2" viewBox="0 0 16 16">
                        <path d="M7 14s-1 0-1-1 1-4 5-4 5 3 5 4-1 1-1 1zm4-6a3 3 0 1 0 0-6 3 3 0 0 0 0 6m-5.784 6A2.24 2.24 0 0 1 5 13c0-1.355.68-2.75 1.936-3.72A6.3 6.3 0 0 0 5 9c-4 0-5 3-5 4s1 1 1 1zM4.5 8a2.5 2.5 0 1 0 0-5 2.5 2.5 0 0 0 0 5"/>
                    </svg>
                    Manage Users
                </button>
            </li>
        }
        <li>
            <button class="dropdown-item d-flex align-items-center rounded-bottom action-button" @onclick="Logout">
                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-box-arrow-left me-2" viewBox="0 0 16 16">
                    <path fill-rule="evenodd" d="M6 12.5a.5.5 0 0 0 .5.5h8a.5.5 0 0 0 .5-.5v-9a.5.5 0 0 0-.5-.5h-8a.5.5 0 0 0-.5.5v2a.5.5 0 0 1-1 0v-2A1.5 1.5 0 0 1 6.5 2h8A1.5 1.5 0 0 1 16 3.5v9a1.5 1.5 0 0 1-1.5 1.5h-8A1.5 1.5 0 0 1 5 12.5v-2a.5.5 0 0 1 1 0z"/>
                    <path fill-rule="evenodd" d="M.146 8.354a.5.5 0 0 1 0-.708l3-3a.5.5 0 1 1 .708.708L1.707 7.5H10.5a.5.5 0 0 1 0 1H1.707l2.147 2.146a.5.5 0 0 1-.708.708z"/>
                </svg>                
                Logout
            </button>
        </li>
    </ul>
</div>

@code {
    private string? UserRole { get; set; }
    private bool hasLoaded = false;

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            // Retrieve the role from local storage
            UserRole = await LocalStorage.GetItemAsync<string>("userRole");
            hasLoaded = true;
            StateHasChanged(); // Trigger re-render after loading the role
        }
    }

    private async Task NavigateToUsersPage()
    {
        NavigationManager.NavigateTo("/users");
    }

    private async Task Logout()
    {
        await AuthService.Logout();
    }
}
``` 
Specifically, the code checks the UserRole retrieved from local storage to determine if the logged-in user has the "Manager" role. If the user is a Manager, they are shown a "Manage Users" option in the dropdown, which navigates to a user management page when clicked. This selective rendering allows only authorized users to access certain functionality, enhancing security and aligning with role-based requirements. The Logout method is also provided to handle user sign-out.
